{
  "0": {
    "id": "0",
    "title": "Source Code",
    "content": "Navindoor is an open source tool and is freely available on Github.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/04-SourceCode/",
    "relUrl": "/posts/04-SourceCode/"
  },
  "2": {
    "id": "2",
    "title": "State of the Art of Simulators for Localization",
    "content": "Simulators are a great tool to improve the design, testing and validation of location systems. That is why we can find different attempts in the scientific community. The following is a summary of some of the existing work in the field, as well as a description of its main characteristics. SMILe [1] is an open-source simulation tool for developing and evaluating indoor location methods based on propagation time as location metrics, such as Flight Time (ToF) or Arrival Time Difference (TDoA). This tool is based on the OMNET+++ simulator and a Python functionality package for data analysis and processing. SMILe allows the user to configure a space, where several factors can be changed that significantly affect the performance of the location. These factors include the deployment of different nodes, radio capabilities and the inaccuracy of clocks. In both Navindoor and SMILe there are tools needed for the design, testing and evaluation of location algorithms from ToF. However, while in SMILe other signals are not yet covered, Navindoor covers a wider range of technologies. Even so, SMILe’s ToF signal simulation model is more complex than Navindoor’s simulation model. PyLayers [2] is an open-source radio frequency simulator. It has been designed to evaluate the performance of location algorithms. The radio channel is synthesized using a graph-based ray tracing method. The movement of people is modelled using a virtual force approach. Simulated data can be processed directly with one of the built-in location algorithms or exported to various extensions for external processing. As in the previous case, PyLayers contains a complex simulator for a specific technology. Although it offers the possibility to process the signals within the simulator itself, it emphasizes the export of its results for external processing. In Navindoor, it is chosen to offer an interface for the incorporation of new simulation models, keeping the whole process in the same development environment. Sensor Fusion and Tracking Toolbox [3] is a library developed by Mathworks that includes algorithms and tools to design, simulate and analyze systems that merge data from various sensors in order to track the position and orientation of objects. This library includes functionalities for generating trajectories and scenarios, simulating measurements of inertial sensors (accelerometer, gyroscope, magnetometer), GPS receivers, radar, sonar and infrared, different fusion and estimation algorithms (Kalman filters and particle filters), and tools to visualize, analyze and compare the performance of different algorithms. In this library, as in Navindoor, tools are provided throughout the process of designing location systems. However, in Sensor Fusion and Tracking Toolbox for now only one CLI has been developed, lacking GUI. On the other hand, simulation models in the generation of trajectories are general; they do not simulate a specific asset. In Navindoor the simulation models are focused on the movement of people. References: Jankowski T, Nikodem M. SMILe – Simulator for Methods of Indoor Localization. 2018 International Conference on Indoor Positioning and Indoor Navigation (IPIN). 2018;(September):24–27. Amiot N, Laaraiedh M, Uguen B. PyLayers: An open source dynamic simulator for indoor propagation and localization. 2013 IEEE International Conference on Communications Workshops, ICC 2013. 2013;(July 2014):84–88. Mathworks. Sensor Fusion and Tracking Toolbox; 2018. Available from: https://es.mathworks.com/help/fusion/.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T021_StateOfTheArt/",
    "relUrl": "/posts/02-ToolDescription/T021_StateOfTheArt/"
  },
  "3": {
    "id": "3",
    "title": "Planimetry module",
    "content": "The objective of this module is to characterize the scenario where the experiment takes place. Currently, the trajectories in Navindoor are centred on interior movement, which is why the basic tools are offered to characterise a multi-storey building. This characterization will provide us with information about movement restrictions, position of access points, height between floors, etc. This information can be used by the generation models of trajectories and signals, in addition to the location algorithms. It has been designed a hierarchy of classes presented in figure 1, which represent the objects necessary for the characterization of a building. The node class has been created to represent a point in three-dimensional space. From this object the other classes are constructed within the planimetry module. The walls objects, which represent the walls of the building, are constructed from two node objects. On the other hand, there are also punctual elements, so classes have been created that inherit the properties of node. These are the objects stairs, elevators, doors and beacons. The objects stairs and elevators indicate the exit points of a plant. The objects doors, are defined inside the objects walls, and allow the passage in their environment. Finally, beacons represent access points that generate radio signals ˜frecuencia. The objects mentioned above are stored in a class called level in the form of attributes. Finally, a building class has been created which contains a list of level objects in its attributes. Figure 1. Scheme of the classes. Protruding arrows indicate which class the object is from. While the list inside each box represents the properties that a class contains. For the creation of each of these objects there is a constructor following the bases of object-oriented programming, however the characterization of the planimetry in this way can be very tedious. It is for this reason that has opted for the development of a GUI (figure 2), which will help us in this work. This way you can define nodes objects with simple clicks, and walls joining nodes objects. Also the GUI allows to load images, in PNG format, of the planimetry of interest inside the workspace. This can be done for each of the plants so that we can create a faithful reproduction of the planimetry using the real planes as templates. Once constructed the planimetry we can see the building object in 3D, thanks to the GUI options. Figure 2. Graphical interface for the design of the building planimetry. The image shows the interface with a five-storey building. The external figure is a three-dimensional representation of the building.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T0221_PlanimetryModule/",
    "relUrl": "/posts/02-ToolDescription/T0221_PlanimetryModule/"
  },
  "4": {
    "id": "4",
    "title": "Trajectory module",
    "content": "The objective of this module is to generate trajectories within the created planimetry. The modelling of the trajectories allows to obtain a preview of the behaviour of the algorithms. Motion models take on importance in this module, since the similarity of the results obtained with reality will depend on it. In Navindoor, trajectories are modeled as a succession of points within the planimetry. These points define the sections through which the asset will move. These can be defined with the help of GUI, simply by doing click within the planimetry, including plant changes. Once the points through which the asset will pass have been defined, with the help of simulation models a succession of finer points is generated. This contains coordinates of the points, as well as the corresponding time instant. In this way, velocities and accelerations can be obtained by differentiation. The generation models of the trajectories in our case are focused on the simulation of a person’s foot, for which measurements of the foot-mounted inertial systems are simulated using the model proposed in [1]. In addition, in cases of plant changes, a constant velocity model is added. From the path of the person’s foot, the path of the center of masses is generated. This will be used in cases where the sensor is on the trunk of the person. Figure 3 shows the process for generating a trajectory object. Figure 3. Process of building a trajectory. In this diagram you can see how the path constructor generates two GroundTruths objects from segments that contain information extracted from the planimetry. In addition, a model is needed that constructs a person&#39;s footpath to trav´es from the segments and a model that is capable of creating the path of the center of masses from the path of the foot. The object Ref GroundTruth represents the path of the center of masses, while Foot GroundTruth represents the path of the person&#39;s foot. It is important to note that both the simulation models of the footpath and the generation model of the path of the center of masses are optional parameters. That is, the simulation models are independent of Navindoor, so new models can be implemented by creating functions with the same input/output interface as the default functions. Finally, in the GUI we have tools for the generation of the trajectory, from the option to create a succession of points with clicks, through the creation of new models, to the visualization of the generated trajectory (figure 4). Figure 4. Capturing an Animation of a Path. It starts on the fifth and ground floor using different stairs and elevators up to the first floor. References: Zampella FJ, Jiménez AR, Seco F, Prieto JC, Guevara JI. Simulation of foot-mounted IMU signals for the evaluation of PDR algorithms. 2011 International Conference on Indoor Positioning and Indoor Navigation, IPIN 2011. 2011.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T0222_TrajectoryModule/",
    "relUrl": "/posts/02-ToolDescription/T0222_TrajectoryModule/"
  },
  "5": {
    "id": "5",
    "title": "Signal generation module",
    "content": "In this module, it is possible to simulate different types of signals from the generated path. The objective is to generate data that the localization algorithms will process. As in the previous module, simulation models are crucial for the behavior of the simulator to be true to reality. In Navindoor, the abstract Signal class has been created with properties that contain the information of the measurements over a period of time. In addition, two classes have been created that inherit the methods and properties of the class Signal. These are: The BeaconBased class: Representing signals that need access points in order to be simulated. The BeaconFree class: Representing signals that can be simulated without the need for access points. Within the simulation environment, the differences between these classes are seen in the way they are constructed. While the BeaconFree class only needs trajectory information to be defined, the BeaconBased class needs the beacons objects defined in the planimetry module (figure 5). Figure 5. Representation of signal generation. A diagram of the BeaconFree and BeaconBased signal generation is shown. In addition, the Signal class from which the properties where the measurements will be are inherited is also shown. The BeaconBased class can represent attenuation signals of power level (RSS), arrival angle (AoA) and flight time (ToF), while the BeaconFree class can represent inertial signals (linear accelerations and angular velocities), magnetic field strengths and atmospheric pressure. The default signal simulation models are basic with a Gaussian noise component. In Navindoor models are treated as input parameters, so it is possible to change them for more complex models simply by creating functions with a specific input/output interface. In the case of BeaconBased classes, the input parameters must be a trajectory point and a beacon object; and the output parameter must be the value of the signal. While in the case of the BeaconFree class, only one point of the path is used as the input parameter and the value of the signal as the output parameter. On the GUI side, Navindoor has implemented a section for signal generation. This shows a list of previously generated paths. It also shows a selector where you can choose the type of signal you want to generate. For each one of these types it shows a list of the existing models. It also allows us to create new models from a template for each type of signal. In this way inside the GUI we can create several signals quickly, besides visualizing the obtained result.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T0223_SignalGenerationModule/",
    "relUrl": "/posts/02-ToolDescription/T0223_SignalGenerationModule/"
  },
  "6": {
    "id": "6",
    "title": "Signal processing module",
    "content": "The objective of this module is to provide the user with basic algorithms for locating the generated signals. These algorithms will be used as a starting point for the design of new ones. In Navindoor the Extended Kalman Filter (EKF) and the Unscented Kalman Filter (UKF) are implemented. To implement new algorithms it is necessary that they have a specific input/output interface. The algorithms must have three input parameters: The building object, a list of signals generated in all time instants and a structure with all the a priori information of the trajectory. They must also have as output parameter a four-column matrix. The first three columns indicating space and the last column indicating time (figure 6). Navindoor processes this information to create a trajectory object. In this way the estimation will have the properties and methods of the real path. Figure 6. Input/output interface for location algorithms. As input it has three variables, the first one representing the planimetry, the second one representing all the previous knowledge about the trajectory and the third one a list of the signals. The algorithm returns a 4 X N matrix, N being the number of measurements. With respect to the GUI, Navindoor shows a list of the trajectories that have been generated. For each of these paths we can see the available signals. In this way we can select the trajectory and the signals. that we want to process. Since the algorithms have the input/output interface presented above, it is possible to execute them with a single click. Navindoor, after executing the algorithm shows the real trajectory and the estimated trajectory within the loaded planimetry. Also, thanks to the fact that the estimation is a trajectory object, we can use the animation used in the trajectory generation module, giving a real time view of the behavior of the real trajectory versus the estimated trajectory.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T0224_SignalProcessingModule/",
    "relUrl": "/posts/02-ToolDescription/T0224_SignalProcessingModule/"
  },
  "7": {
    "id": "7",
    "title": "Evaluation module",
    "content": "The aim of this last module is to compare different estimates of the trajectory. The difference of the executions can be in the algorithm used to estimate, however it can also be in the simulation models of the trajectory, in the simulation models of signals, or simply in the frequency of sampling of some signal. We should note that the estimates in Navindoor are objects trajectories so from the point of view of the code, there is no structural difference between the actual trajectory and the estimate. This makes the comparison between them easier. In the GUI, Navindoor shows us a list of the generated trajectories, being able to select one of them. For each of these trajectories the available estimates are shown. We can select the estimates we want to compare them in the same graph representing the empirical cumulative distribution function (eCDF), taking as reference the real trajectory. In this way we have a view of the behaviour of the two estimates in the same graph.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T0225_EvaluationModule/",
    "relUrl": "/posts/02-ToolDescription/T0225_EvaluationModule/"
  },
  "8": {
    "id": "8",
    "title": "Navindoor modules",
    "content": "Navindoor has been developed under the paradigm of object-oriented programming. Classes have been defined to represent elements in the design of location systems. The planimetry, trajectories or signals are classes that contain associated methods for their visualization, data extraction and interaction between them. On the other hand, we have location algorithms and metrics to compare algorithms. These are represented by functions that act on the above mentioned classes. These classes and functions have been developed in five modules that follow the process of experimentation in the design of location systems. In order to have a global vision of it, this process and the module proposed in each point will be briefly described: Obtaining the planimetry. The first step in the experimentation is the choice of the scenario and the obtaining of the planimetry. In Navindoor, the planimetry module has been created with the necessary classes for to build a multi-level planimetry. Generation of trajectories. In the experimentation, reference points are taken in order to be able to construct trajectories through them. This limits the variety of trajectories, however it is necessary to obtain precise measurements of the position at any given moment. Navindoor has created the module for generating trajectories, dedicated to the simulation of trajectories. Because we are in a simulation environment we have exact information about the real trajectory, generated from a succession of points provided by the user. Signal measurement. In experimentation, once the trajectory has been generated, it must be enriched with signals. The third module, called the signal generation module, is dedicated to simulation. of synthetic signals. Thanks to simulation, we can create the signals after the trajectory has been generated. Signal processing. After taking measurements, the locating algorithms process the signals. The fourth Navindoor module, called the measurement processing module, provides algorithms capable of creating estimates of the real trajectory from the simulated signals. It also offers a scheme where new algorithms can be developed. Algorithm Comparison. Finally, in order to validate the developed algorithms it is necessary to compare them with other already consolidated algorithms. The fifth module of Navindoor is the validation module of algorithms, which provide us with methods of comparing algorithms provided by the user or between algorithms by default. Within these modules are distributed the classes and functions defined in Navindoor. It is worth mentioning that both CLI and GUI are compatible in MATLAB versions higher than MATLAB R2017b. Details of each module are presented next.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T022_ModulesIntro/",
    "relUrl": "/posts/02-ToolDescription/T022_ModulesIntro/"
  },
  "9": {
    "id": "9",
    "title": "Navindoor description",
    "content": "The methodologies used for the design, testing and validation of localization systems are as varied as the diversity of technologies and techniques used for their implementation. However, there are a number of common steps in the design of localization systems. These are: the obtaining of the planimetry, the generation of trajectories, the taking of measurements of signals in this trajectory, the processing of the signals and finally the evaluation of their performance by comparison. The measurements taken should be varied, since a collection of few cases can add unwanted biases to our systems. It is therefore necessary to test in various environments, taking measurements in different trajectories. However, obtaining experimental measures of this type are costly in terms of time and resources. Consequently, simulation tools are a very interesting alternative. Good simulation models, both in the trajectory and in the generation of signals, can generate a wide range of tests. However, for now there is no standard framework to develop algorithms of various kinds. The few simulators that exist are usually focused on a particular technology, which does not allow comparison with other types of location systems. This article presents the simulation platform, Navindoor. This is an open source library for MATLAB, where the user can build the planimetry, generate trajectories, simulate signals, develop algorithms, and compare them with others. Navindoor contains a graphical interface (GUI), which facilitates the interaction with the platform. In addition, it contains a command line interface (CLI), which facilitates automating voluminous simulations and integration with other tools. Unlike other location system simulation platforms, where simulation models are anchored to the design, this has been developed in a modular way. Due to this, the implementation of new models and algorithms is more versatile. Within Navindoor we can use MATLAB functions as input parameters. In this way developing a simulation model or location algorithm is simplified in creating a MATLAB function, with a specific input/output interface.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/02-ToolDescription/T02_ToolDescription/",
    "relUrl": "/posts/02-ToolDescription/T02_ToolDescription/"
  },
  "10": {
    "id": "10",
    "title": "Presentations",
    "content": "Presentation of Navindoor - June 2018 Presentation of Navindoor - January 2019",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/03-Documentation/T031_Presentations/",
    "relUrl": "/posts/03-Documentation/T031_Presentations/"
  },
  "11": {
    "id": "11",
    "title": "Tutorials",
    "content": "Under construction…..",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/03-Documentation/T032_Tutorials/",
    "relUrl": "/posts/03-Documentation/T032_Tutorials/"
  },
  "12": {
    "id": "12",
    "title": "API reference",
    "content": "Under construction…..",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/03-Documentation/T033_API/",
    "relUrl": "/posts/03-Documentation/T033_API/"
  },
  "13": {
    "id": "13",
    "title": "Papers",
    "content": "Oroya, J., Díez, L. E., &amp; Bahillo, A. (2019). Navindoor: Plataforma de simulación para el diseño, prueba y evaluación de sistemas de localización. Córdoba, Spain. [PDF file]",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/03-Documentation/T034_Papers/",
    "relUrl": "/posts/03-Documentation/T034_Papers/"
  },
  "14": {
    "id": "14",
    "title": "Documentation",
    "content": "This section contains documentation of different types on the Navindoor tool.",
    "url": "https://deustotech.github.io/navindoor-documentation/posts/03-Documentation/T03_Documentation/",
    "relUrl": "/posts/03-Documentation/T03_Documentation/"
  },
  "15": {
    "id": "15",
    "title": "Home",
    "content": "A simulation tool for the design, testing and evaluation of localization algorithms. Navindoor is a platform developed in Matlab that provides the necessary tools to define all the elements that come into play in the different phases of the simulation of a localization system: definition of the scenario, definition of the trajectory and dynamics of the moving object, synthetic generation of signals of different types and characteristics, processing of these signals through different algorithms and evaluation and comparison of the results of the estimates. Navindoor has been designed in an extensible way, so that it is easy to implement and incorporate new signal and dynamic models and localization algorithms.",
    "url": "https://deustotech.github.io/navindoor-documentation/",
    "relUrl": "/"
  }
  
}
